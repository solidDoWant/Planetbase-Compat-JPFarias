using System;
using System.Collections.Generic;
using System.Linq;
using Mono.Cecil;
using PlanetbaseFramework.Cecil;
using PlanetbaseFramework.Extensions;

namespace Planetbase_Compat_JPFarias.Builders
{
    public class PrefixMethodBuilder
    {
        /// <summary>
        ///     The DLL containing the Redirector patch.
        /// </summary>
        public ModuleDefinition ModDll { get; }

        /// <summary>
        ///     The method that has the Redirector annotation.
        /// </summary>
        public MethodDefinition AnnotatedMethod { get; }

        /// <summary>
        ///     The class that Redirector is targeting.
        /// </summary>
        public TypeReference TargetedClass { get; }

        public MethodDefinition TargetedMethod { get; }

        /// <summary>
        ///     The method generated by this builder.
        /// </summary>
        protected MethodDefinition PrefixMethod { get; set; }

        public PrefixMethodBuilder(ModuleDefinition modDll, MethodDefinition annotatedMethod,
            TypeReference targetedClass)
        {
            ModDll = modDll;
            AnnotatedMethod = annotatedMethod;
            TargetedClass = targetedClass;
            TargetedMethod = GetTargetedMethod();
        }

        protected MethodDefinition GetTargetedMethod()
        {
            var possibleMatchedMethods = FindTargetedMethodCandidates().ToList();

            switch (possibleMatchedMethods.Count)
            {
                case 0:
                    throw new Exception(
                        $"Failed to find a method on {TargetedClass.FullName} with a signature matching {AnnotatedMethod.FullName}");
                case 1:
                    break;
                default:
                    throw new Exception(
                        $"Found {possibleMatchedMethods.Count} methods with a signature matching {AnnotatedMethod.FullName} in type {TargetedClass.FullName}, 1 expected.");
            }

            return possibleMatchedMethods[0];
        }

        protected IEnumerable<MethodDefinition> FindTargetedMethodCandidates()
        {
            const MethodAttributes ignoredAttributes = MethodAttributes.MemberAccessMask | MethodAttributes.Virtual;
            return TargetedClass
                .Resolve()
                .Methods
                .Where(method => method.Name == AnnotatedMethod.Name)
                .Where(method => !method.IsAbstract)
                .Where(method =>
                    (method.Attributes | ignoredAttributes) ==
                    (AnnotatedMethod.Attributes | ignoredAttributes))
                .Where(method => method.Parameters.Count == AnnotatedMethod.Parameters.Count)
                .Where(method => method.ReturnType.IsSameTypeAs(AnnotatedMethod.ReturnType))
                .Where(method =>
                    method.Parameters.Select(parameter => parameter.ParameterType).AreCollectionsIdentical(
                        AnnotatedMethod.Parameters.Select(parameter => parameter.ParameterType),
                        (param1, param2) => param1.IsSameTypeAs(param2)));
        }

        /// <summary>
        ///     Builds a "Prefix" method for Harmony that will call the annotated JPFarias method, and
        ///     prevent execution of the rest of the targeted method's body. This mimics Redirector
        ///     behavior.
        /// </summary>
        /// <returns>The created method.</returns>
        public MethodDefinition Build()
        {
            PrefixMethod = CreateMethodDefinition();
            AddParameters();
            AddCustomAttributes();
            AddSecurityAnnotations();
            BuildMethodBody();
            return PrefixMethod;
        }

        /// <summary>
        ///     Defines a method with signature <c>public static bool Prefix</c>
        /// </summary>
        /// <returns>The created method.</returns>
        protected MethodDefinition CreateMethodDefinition()
        {
            return new MethodDefinition(
                "Prefix",
                MethodAttributes.Public | MethodAttributes.HideBySig | MethodAttributes.Static,
                ModDll.TypeSystem.Boolean
            );
        }

        /// <summary>
        ///     Adds the parameters to the method. This changes the signature to:
        ///     <code>
        ///     public static bool Prefix(&lt;TargetedClass&gt; __instance, &lt;ParameterType1&gt; &lt;ParameterName1&gt;...,
        ///         ref AnnotatedMethod.ReturnType __result)
        ///     </code>
        ///     The <c>__instance</c> and <c>__result</c> parameters are conditional on the targeted method being an
        ///     instance method and non-void method, respectively.
        /// </summary>
        protected void AddParameters()
        {
            if (!AnnotatedMethod.IsStatic)
            {
                // Making the first parameter __instance will make ldarg op codes line up on instance methods
                var instanceParameter = new ParameterDefinition("__instance", ParameterAttributes.None, TargetedClass);
                PrefixMethod.Parameters.Add(instanceParameter);
            }

            foreach (var pair in AnnotatedMethod.Parameters.Zip(
                         TargetedMethod.Parameters.Select(parameter => parameter.Name)))
            {
                // Set the annotated method's parameter name to the targeted method parameter's name.
                // There are a few cases with mods created for older versions of the game where these
                // don't match up, which can cause issues with Harmony.
                pair.Item1.Name = pair.Item2;
                PrefixMethod.Parameters.Add(pair.Item1);
            }

            if (AnnotatedMethod.ReturnType == ModDll.TypeSystem.Void) return;

            var refReturnType = new ByReferenceType(AnnotatedMethod.ReturnType);
            var resultParameter = new ParameterDefinition("__result", ParameterAttributes.None, refReturnType);
            PrefixMethod.Parameters.Add(resultParameter);
        }

        /// <summary>
        ///     Adds attributes from the annotated method to the new patch method.
        /// </summary>
        protected void AddCustomAttributes()
        {
            foreach (var nonRedirectAttribute in AnnotatedMethod.CustomAttributes.Where(nonRedirectAttribute =>
                         !nonRedirectAttribute.AttributeType.HasTypeAsParent("Redirection.RedirectAttribute")))
                PrefixMethod.CustomAttributes.Add(nonRedirectAttribute);
        }

        /// <summary>
        ///     Adds security annotations from the annotated method to the new patch method.
        ///     I have no idea what this does or if it is needed.
        /// </summary>
        protected void AddSecurityAnnotations()
        {
            foreach (var securityDeclaration in AnnotatedMethod.SecurityDeclarations)
                PrefixMethod.SecurityDeclarations.Add(securityDeclaration);
        }

        /// <summary>
        ///     Creates the method body. This should define the method as follows:
        ///     <code>
        ///     public bool Prefix(T __instance, &lt;parameters&gt;..., ref V __result)
        ///     {
        ///     // If the targeted method is void then __result is neither defined nor set
        ///     __result = AnnotatedMethod(&lt;parameters&gt;);
        ///     // Prevents the targeted method from being called
        ///     return false;
        ///     }
        ///     </code>
        /// </summary>
        protected void BuildMethodBody()
        {
            var ilProcessor = PrefixMethod.Body.GetILProcessor();

            ilProcessor.AddNopInstruction();
            if (AnnotatedMethod.ReturnType != ModDll.TypeSystem.Void)
                ilProcessor.PushParameterOntoStack(
                    PrefixMethod.Parameters.First(parameter => parameter.Name == "__result"));
            if (AnnotatedMethod.HasThis && !AnnotatedMethod.ExplicitThis)
                ilProcessor.PushInstanceOntoStack();
            // This is a trick to get only the prefix method parameters that correspond to the annotated method's
            // parameters. A few things to note:
            // 1. The parameters will be in the same order as the prefix method because of the prefix method's
            //    parameters are added by looping over the annotated method's parameters.
            // 2. The sequence number of the parameters should line up because both the functions will either
            //    have an instance of the type as the first parameter (this or __instance), depending on
            //    whether the annotated method is static or not.
            // 3. The __result parameter is added after the parameters, so it won't shift the parameter sequence
            //    number.
            ilProcessor.PushParametersOntoStack(AnnotatedMethod.Parameters);
            ilProcessor.CallMethod(AnnotatedMethod);
            if (AnnotatedMethod.ReturnType != ModDll.TypeSystem.Void)
                ilProcessor.StoreCallResult(AnnotatedMethod.ReturnType);
            ilProcessor.ReturnBoolean(ModDll.TypeSystem.Boolean, false);
        }
    }
}